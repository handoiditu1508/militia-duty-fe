==========> useState <==========
- pass in an initial state
- return [state, setState]
- setState can acception object or prev => {} func
- new state returned in setState func must use spread operator {...state} [...state]
==========> useState <==========

==========> useEffect <==========
- used to handle componentDidMount, componentUpdated, componentWillUmount
- first parameter is a function that run after every renders (likes componentUpdated)
- second parameter is an array of dependencies to prevent useEffect hook from rerun
- to run effect only once (likes componentDidMount), define second parameter to an empty array []
- first parameter return a function which run before every rerenders, we can use this function to cancel watchers, timers, ... (likes componentWillUmount)
- can use multiple useEffects to group related logics
==========> useEffect <==========

==========> useContext <==========
- used to consume context value in context provider
- first parameter is the Context instance export from the source
- return context value
- can call multiple useContexts for different contexts
==========> useContext <==========

==========> useReducer <==========
- used to manage a state object
- first parameter is a reducer function, second parameter is a initial state
- reducer function accept 2 parameters:
  + current state
  + action: an object passed in dispatch function {type: string, payload: any}
- reducer function return new state object, also need spread operator {...state} [...state]
- reducer function update the state base on action.type value, default return current state
- useReducer returns [state, dispatch]
- dispatch function accepts an object {type: string, payload: any} which will be passed to reducer function
==========> useReducer <==========

==========> useRef <==========
- create a reference variable that can reference to component, element, string, number, ...
- when component rerender, variable created by useRef persist (likes state)
- unlike state, variable created by useRef doesn't cause additional rerender when change
- good for holding value that assigned once in useEffect so when component rerender, variable won't be reset
==========> useRef <==========

==========> useCallback <==========
- used to cache function, because function is recreate every render, when pass function as prop, child component doesn't know if function is the same or not and will rerender itself unnecessarily
- first parameter is function we want to cache, second parameter is an array of dependencies
- returns a cached function
==========> useCallback <==========

==========> useMemo <==========
- used to cache result from a function, because function might take long to generate result and when unrelated state changed => component rerender => function recalculated.
- first parameter is function whose result we want to cache, second parameter is an array of dependencies
- returns a cached result
==========> useMemo <==========

==========> React.memo <==========
- likes PureComponent, only rerender component when props or states changed (equality compare)
- Export default React.memo(MyComponent) instead of Export default MyComponent
==========> React.memo <==========

==========> Notes <==========
- useCallback - cache a function, useMemo - cache result from function
- it's unnecessary to use useCallback, useMemo and React.memo all the time since they also do calculation and allocation under the hood which slow down our app.
- use useCallback when function is passed as prop to child component and child component is costly to rerender, child component also has to wrap in HOC React.memo(Component) to do equality compare on function prop
- use useMemo when result generated by function are costly or take long time
- use React.memo for component which take substantial amount of time to render (graphs, charts, animations, ...)
==========> Notes <==========

==========> Type notes <==========
- types can be union using |
- types can be intersect using &
- type P = keyof {name: string; age: number;}. P = "name" | "number"
- never type is used to blocking specific properties from including in a type
- Exclude<ButtonVariant, "primary"> exclude "primary" from type ButtonVariant
- React.ComponentProps<typeof CustomButton>
- React.ComponentProps<"button">
- Omit<ButtonProps, "disabled"> to remove disabled prop from type ButtonProps
- Omit<ButtonProps, keyof LinkProps> to remove from ButtonProps all properties with the same name as LinkProps's properties
- Pick<ButtonProps, "disabled" | "color"> to create a type with disabled and color props from ButtonProps
- React.ElementType consist of "div", "button", "input", ... is used for dynamic programming
- React.ReactNode: consist of string, number, component, element, ...
- React.CSSProperties: consist of color, border, width, height, ...
- Partial<CustomType> to make all properties optional
- Required<CustomType> to make all properties required
- Awaited<boolean | Promise<number> | Promise<Promise<string>>> == (boolean | number | string)
==========> Type notes <==========

==========> useNavigate <==========
- return function to navigate between routes
- initiate: const navigate = useNavigate()
- usage: navigate("about")
- go back to previous page: navigate(-1)
- navigate and replace history: navigate("about", {replace: true})
- we can also use navigate component to navigate: <Navigate to="/login" replace state={{redirect: "/"}} />
- and use location.state.redirect (see useLocation below)
==========> useNavigate <==========

==========> useParams <==========
- return param object from url
- initiate: const { userId } = useParam()
==========> useParams <==========

==========> useSearchParams <==========
- used to manipulate url queries
- initiate: const [searchParams, setSearchParams] = useSearchParams()
- get: searchParams.get("genre")
- set: setSearchParams({ genre: "action", year: "2022" })
==========> useSearchParams <==========

==========> useLocation <==========
- used to get current location info
- initiate: const location = useLocation()
- location.hash return url tag begin with '#'
- location.pathname return url path begin with '/'
- location.search return url query string begin with '?'
==========> useLocation <==========

==========> check {to} match current url <==========
- const resolved = useResolvedPath(to);
- const match = useMatch({ path: resolved.pathname, end: true });
==========> check {to} match current url <==========

==========> useTheme <==========
- const theme = useTheme()
- theme.palette.primary.main
==========> useTheme <==========


==========> which MUI overlay method to use <==========
- dialog:
  + position: center of the screen
  + content: card or any UI
- portal:
  + position: any position
  + content: any UI
- menu:
  + position: relative to an anchor element
  + content: dropdown list
- popper:
  + position: relative to an anchor element
  + content: any UI
==========> which MUI overlay method to use <==========